// –ü—Ä–æ—Å—Ç–∞—è in-memory –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞—Ä—Ç–æ—á–µ–∫ –∏ —Å–µ—Ç–æ–≤
import * as FileSystem from 'expo-file-system';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { parseCSV, CSVParseError } from './csv-parser';
import { groceryStoreData } from './data/grocery-store-data';
import { startupsData } from './data/startups-data';
import { workInItData } from './data/work-in-it-data';

export type Card = {
  id: string;
  word: string;
  translation: string;
  sentences: string[];
  repeatCount: number;
  status: 'learning' | 'learned';
  setId: string;
  successCount: number;
  isArchived: boolean;
  lastReviewed: number;
};

export type CardSet = {
  id: string;
  name: string;
  fileName: string;
  color?: string;
  icon?: string;
  learnedCards: number;
  totalCards: number;
  archivedCards: number;
};

const SETS_DIR = FileSystem.documentDirectory + 'sets/';
const PROGRESS_STORAGE_KEY = 'moinaki_card_progress';

// –ü–∞–ª–∏—Ç—Ä–∞ –∫–∏—Å–ª–æ—Ç–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤
const ACID_COLORS = [
  '#FF1493', // Deep Pink (—Ñ—É–∫—Å–∏—è)
  '#00BFFF', // Deep Sky Blue (—è—Ä–∫–æ-–≥–æ–ª—É–±–æ–π)
  '#00FF7F', // Spring Green (–Ω–µ–æ–Ω–æ–≤–æ-–∑–µ–ª–µ–Ω—ã–π)
  '#FF4500', // Orange Red (–æ—Ä–∞–Ω–∂–µ–≤–æ-–∫—Ä–∞—Å–Ω—ã–π)
  '#9400D3', // Dark Violet (—Ç–µ–º–Ω–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π)
  '#FFD700', // Gold (–∑–æ–ª–æ—Ç–æ–π)
  '#FF69B4', // Hot Pink (–≥–æ—Ä—è—á–∏–π —Ä–æ–∑–æ–≤—ã–π)
  '#00CED1', // Dark Turquoise (—Ç–µ–º–Ω–æ-–±–∏—Ä—é–∑–æ–≤—ã–π)
  '#FF6347', // Tomato (—Ç–æ–º–∞—Ç–Ω—ã–π)
  '#8A2BE2', // Blue Violet (—Å–∏–Ω–µ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π)
  '#32CD32', // Lime Green (–ª–∞–π–º–æ–≤—ã–π)
  '#FF1493', // Deep Pink (–¥—É–±–ª–∏—Ä—É–µ–º –¥–ª—è –±–æ–ª—å—à–µ–≥–æ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
];

// –ü—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –Ω–∞–±–æ—Ä—ã –¥–∞–Ω–Ω—ã—Ö
const PRESET_SETS = [
  { 
    name: 'grocery store.csv', 
    data: groceryStoreData, 
    color: '#FF1493', 
    icon: 'üõí' 
  },
  { 
    name: 'startups.csv', 
    data: startupsData, 
    color: '#00BFFF', 
    icon: 'üöÄ' 
  },
  { 
    name: 'work in IT.csv', 
    data: workInItData, 
    color: '#00FF7F', 
    icon: 'üíª' 
  },
];

let sets: CardSet[] = [];
let cards: Card[] = [];
let initialized = false;

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–Ω–¥–æ–º–Ω–æ–≥–æ –∫–∏—Å–ª–æ—Ç–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
function getRandomAcidColor(): string {
  return ACID_COLORS[Math.floor(Math.random() * ACID_COLORS.length)];
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –≤ CSV —Ñ–æ—Ä–º–∞—Ç
function dataToCSV(data: any[]): string {
  const headers = 'word,translation,sentences\n';
  const rows = data.map(item => {
    const sentences = Array.isArray(item.sentences) ? item.sentences.join('|') : item.sentences;
    return `${item.word},${item.translation},"${sentences}"`;
  });
  return headers + rows.join('\n');
}

async function ensurePresetFiles() {
  await FileSystem.makeDirectoryAsync(SETS_DIR, { intermediates: true }).catch(() => {});
  for (const preset of PRESET_SETS) {
    const dest = SETS_DIR + preset.name;
    const exists = await FileSystem.getInfoAsync(dest);
    if (!exists.exists) {
      // –°–æ–∑–¥–∞–µ–º CSV —Ñ–∞–π–ª –∏–∑ –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
      const csvContent = dataToCSV(preset.data);
      await FileSystem.writeAsStringAsync(dest, csvContent, { encoding: FileSystem.EncodingType.UTF8 });
    }
  }
}

async function loadProgressFromStorage(): Promise<Record<string, { successCount: number; isArchived: boolean; lastReviewed: number }>> {
  try {
    const progressData = await AsyncStorage.getItem(PROGRESS_STORAGE_KEY);
    return progressData ? JSON.parse(progressData) : {};
  } catch (error) {
    console.error('Error loading progress:', error);
    return {};
  }
}

async function saveProgressToStorage(progress: Record<string, { successCount: number; isArchived: boolean; lastReviewed: number }>) {
  try {
    await AsyncStorage.setItem(PROGRESS_STORAGE_KEY, JSON.stringify(progress));
  } catch (error) {
    console.error('Error saving progress:', error);
  }
}

async function loadSetsAndCards() {
  sets = [];
  cards = [];
  const progressData = await loadProgressFromStorage();
  const files = await FileSystem.readDirectoryAsync(SETS_DIR);
  let setIndex = 0;
  for (const fileName of files) {
    if (!fileName.endsWith('.csv')) continue;
    const fileUri = SETS_DIR + fileName;
    
    try {
      const content = await FileSystem.readAsStringAsync(fileUri);
      const parsed = parseCSV(content);
      const setId = fileName;
      
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç: –¥–ª—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–¥–∞–Ω–Ω—ã–π, –¥–ª—è –Ω–æ–≤—ã—Ö - —Ä–∞–Ω–¥–æ–º–Ω—ã–π
      const presetFile = PRESET_SETS.find(p => p.name === fileName);
      const color = presetFile ? presetFile.color : getRandomAcidColor();
      const icon = presetFile ? presetFile.icon : 'üìö';
      
      sets.push({
        id: setId,
        name: fileName.replace('.csv', '').replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        fileName,
        color: color,
        icon: icon,
        learnedCards: 0,
        totalCards: parsed.length,
        archivedCards: 0,
      });
      
      for (const item of parsed) {
        const cardId = `${setId}-${item.word}`;
        const savedProgress = progressData[cardId] || { successCount: 0, isArchived: false, lastReviewed: 0 };
        cards.push({
          id: cardId,
          word: item.word,
          translation: item.translation,
          sentences: Array.isArray(item.sentences) ? item.sentences : [],
          repeatCount: 0,
          status: 'learning',
          setId,
          successCount: savedProgress.successCount,
          isArchived: savedProgress.isArchived,
          lastReviewed: savedProgress.lastReviewed,
        });
      }
      setIndex++;
    } catch (error) {
      console.error(`Error loading file ${fileName}:`, error);
      // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã, –Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
      if (error instanceof CSVParseError) {
        console.warn(`Skipping corrupted CSV file ${fileName}: ${error.message}`);
      }
    }
  }
}

export const database = {
  async init() {
    if (initialized) return;
    initialized = true;
    await ensurePresetFiles();
    await loadSetsAndCards();
  },

  async getCardSets(): Promise<CardSet[]> {
    await loadSetsAndCards();
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–µ—Ç–∞
    return sets.map(set => {
      const setCards = cards.filter(card => card.setId === set.id);
      const learned = setCards.filter(card => card.status === 'learned').length;
      const archived = setCards.filter(card => card.isArchived).length;
      return {
        ...set,
        learnedCards: learned,
        totalCards: setCards.length,
        archivedCards: archived,
      };
    });
  },

  async createCardSet(name: string, csvContent: string): Promise<string> {
    try {
      // –í–∞–ª–∏–¥–∏—Ä—É–µ–º CSV –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
      parseCSV(csvContent);
      
      const fileName = name.replace(/\s+/g, '_').toLowerCase() + '.csv';
      const fileUri = SETS_DIR + fileName;
      await FileSystem.writeAsStringAsync(fileUri, csvContent, { encoding: FileSystem.EncodingType.UTF8 });
      await loadSetsAndCards();
      return fileName;
    } catch (error) {
      if (error instanceof CSVParseError) {
        throw new Error(`Invalid CSV format: ${error.message}`);
      }
      throw new Error('Failed to create card set. Please check your file format.');
    }
  },

  async addCards(newCards: Omit<Card, 'id'>[]): Promise<void> {
    // –ù–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç.–∫. —Ç–µ–ø–µ—Ä—å –∫–∞—Ä—Ç–æ—á–∫–∏ —á–∏—Ç–∞—é—Ç—Å—è –∏–∑ —Ñ–∞–π–ª–æ–≤
  },

  async getCardsForLearning(setId: string, limit: number): Promise<Card[]> {
    await loadSetsAndCards();
    const setCards = cards.filter(card => card.setId === setId);
    const archivedCards = setCards.filter(card => card.isArchived);
    const nonArchivedCards = setCards.filter(card => !card.isArchived);
    
    // –ï—Å–ª–∏ –≤—Å–µ —Å–ª–æ–≤–∞ –≤ –∞—Ä—Ö–∏–≤–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∞—Ä—Ö–∏–≤–Ω—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏
    if (nonArchivedCards.length === 0 && archivedCards.length > 0) {
      return archivedCards.slice(0, limit);
    }
    
    // –ò–Ω–∞—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ã—á–Ω—ã–µ —Å–ª–æ–≤–∞ + –∞—Ä—Ö–∏–≤–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞–ª–∏—Å—å –Ω–µ–¥–µ–ª—é
    const now = Date.now();
    const oneWeek = 7 * 24 * 60 * 60 * 1000; // 7 –¥–Ω–µ–π –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    
    const availableCards = setCards.filter(card => 
      !card.isArchived || (now - card.lastReviewed) > oneWeek
    );
    
    return availableCards.slice(0, limit);
  },

  async getArchivedCardsForTraining(setId: string, limit: number): Promise<Card[]> {
    await loadSetsAndCards();
    const archivedCards = cards.filter(card => 
      card.setId === setId && card.isArchived
    );
    return archivedCards.slice(0, limit);
  },

  async isSetFullyArchived(setId: string): Promise<boolean> {
    await loadSetsAndCards();
    const setCards = cards.filter(card => card.setId === setId);
    return setCards.length > 0 && setCards.every(card => card.isArchived);
  },

  async updateCardProgress(cardId: string, correct: boolean): Promise<void> {
    const card = cards.find(c => c.id === cardId);
    if (card) {
      card.lastReviewed = Date.now();
      
      if (correct) {
        card.successCount += 1;
        card.status = 'learned';
        
        // –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ 50 —É—Å–ø–µ—à–Ω—ã—Ö –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π, –∞—Ä—Ö–∏–≤–∏—Ä—É–µ–º
        if (card.successCount >= 50) {
          card.isArchived = true;
        }
      } else {
        card.repeatCount += 1;
      }
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –≤ AsyncStorage
      const progressData = await loadProgressFromStorage();
      progressData[cardId] = {
        successCount: card.successCount,
        isArchived: card.isArchived,
        lastReviewed: card.lastReviewed,
      };
      await saveProgressToStorage(progressData);
    }
  },

  async deleteCardSet(setId: string): Promise<void> {
    const fileUri = SETS_DIR + setId;
    await FileSystem.deleteAsync(fileUri, { idempotent: true });
    
    // –£–¥–∞–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –∫–∞—Ä—Ç–æ—á–µ–∫ —ç—Ç–æ–≥–æ —Å–µ—Ç–∞
    const progressData = await loadProgressFromStorage();
    const cardIdsToRemove = Object.keys(progressData).filter(id => id.startsWith(setId));
    cardIdsToRemove.forEach(id => delete progressData[id]);
    await saveProgressToStorage(progressData);
    
    await loadSetsAndCards();
  },

  async getCardById(cardId: string): Promise<Card | null> {
    await loadSetsAndCards();
    return cards.find(card => card.id === cardId) || null;
  },

  async getCardProgress(cardId: string): Promise<{ successCount: number; isArchived: boolean; lastReviewed: number } | null> {
    const card = cards.find(c => c.id === cardId);
    if (card) {
      return {
        successCount: card.successCount,
        isArchived: card.isArchived,
        lastReviewed: card.lastReviewed,
      };
    }
    return null;
  },
};